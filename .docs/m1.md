# Milestone 1: Beautiful Interface Foundation

> **Goal**: A stunning, functional workspace with Bonsplit-powered flexible panels and multi-workspace support.

---

## Progress Tracker

| Phase | Status | Date Completed |
|-------|--------|----------------|
| Phase 0: Project Setup | âœ… Complete | 2026-01-30 |
| Phase 0.5: Design System & App Shell | âœ… Complete | 2026-01-30 |
| Phase 1: Workspace System | ðŸ”„ Pending | - |
| Phase 2: File System Core | ðŸ”„ Pending | - |
| Phase 3: File Tree UI | â³ Pending | - |
| Phase 4: DevysSyntax Core | â³ Pending | - |
| Phase 5: File Viewer | â³ Pending | - |
| Phase 6: Bonsplit Integration | âœ… Complete | 2026-01-30 |
| Phase 7: Activity Sidebar | âœ… Complete | 2026-01-30 |
| Phase 8: Polish & Testing | â³ Pending | - |

**Current Status**: App shell complete with Bonsplit integration, design system, activity sidebar, and light/dark mode toggle. Ready for workspace/file system implementation.

---

## Overview

Milestone 1 establishes the foundational architecture and visual identity of Devys. By the end of this milestone, users will be able to:

- Create and switch between workspaces (each representing a folder)
- Navigate files in a sidebar file explorer
- Open files in Bonsplit-powered tabs
- Split panes horizontally and vertically
- Drag tabs between panes
- Resize panes smoothly at 120fps
- Experience the Devys design system in action

**No editing, git, terminal, or agent features yet** â€” those come in later milestones. M1 is purely about the shell: workspace management, panel system, and file viewing.

---

## Learnings from CodeEdit

We've analyzed [CodeEdit](https://github.com/CodeEditApp/CodeEdit) (22.6k stars, native macOS editor) and incorporated key architectural decisions:

| Aspect | CodeEdit Approach | Our Approach | Rationale |
|--------|-------------------|--------------|-----------|
| File Tree UI | NSOutlineView | LazyVStack (with NSOutlineView fallback) | Start SwiftUI, migrate if perf issues |
| File Model | Class with parent refs | Class (CEWorkspaceFileNode) | Need reference semantics for tree |
| File Watching | DispatchSource | DispatchSource | Real-time updates essential |
| Virtualization | Native (NSOutlineView) | Flattened list + LazyVStack | Only render visible rows |

**Performance Gate**: If file tree doesn't hit 60fps with 5,000 files, we migrate to NSOutlineView wrapper.

---

## Deliverables

### 1. Project Scaffold

| Item | Description |
|------|-------------|
| Xcode Workspace | `Devys.xcworkspace` with proper scheme configuration |
| macOS App Target | `Devys` app for macOS 14.0+ |
| Swift Packages | Initial structure for `DevysCore`, `DevysUI` |
| Design Tokens | Colors, typography, spacing as Swift code |

### 2. Bonsplit Integration

| Item | Description |
|------|-------------|
| BonsplitController | Integrated controller managing tabs/panes |
| Custom Tab Content | File viewer panels as tab content |
| Split Operations | Horizontal and vertical splits working |
| Tab Drag/Drop | Reordering and moving between panes |
| Empty Pane View | Beautiful "No Open Files" state |

### 3. Workspace System

| Item | Description |
|------|-------------|
| Workspace Model | Data model for workspace (folder path, state) |
| Workspace Manager | Service for CRUD operations on workspaces |
| Workspace Switcher | UI for selecting between workspaces |
| Persistence | Workspaces persisted between app launches |

### 4. File Explorer (Performance-Optimized)

| Item | Description |
|------|-------------|
| CEWorkspaceFileNode | Class-based file model with parent refs (inspired by CodeEdit) |
| FileTreeViewModel | Manages flattened tree for virtualized rendering |
| FileTreeView | LazyVStack-based virtualized tree display |
| File Icons | SF Symbols for different file types |
| Expand/Collapse | Efficient state management with flattening |
| File Selection | Single-click select, double-click open |
| Context Menu | Right-click for file operations |

### 5. File System Watching

| Item | Description |
|------|-------------|
| FileSystemWatcher | DispatchSource-based file/folder monitoring |
| Real-time Updates | Tree auto-updates when files change on disk |
| Debouncing | Batch rapid changes to avoid UI thrashing |
| Scope Management | Watch workspace root + expanded directories |

### 6. File Viewer (Read-Only) with Shiki Highlighting

| Item | Description |
|------|-------------|
| Text Display | Scrollable text view with line numbers |
| **Shiki Highlighting** | Full TextMate-based syntax coloring (17 languages) |
| File Info | File name, size, modified date in tab |
| Live Reload | Re-read file when FS watcher detects change |
| Theme Support | All 13 Shiki themes available |

> **Note**: This requires initial setup of `DevysSyntax` package. See [shiki-integration.md](shiki-integration.md) for full details.

### 7. DevysSyntax Package (Core Engine)

| Item | Description |
|------|-------------|
| Oniguruma Wrapper | Swift wrapper for Oniguruma regex (TextMate requirement) |
| TMTokenizer | Core TextMate tokenization engine |
| ThemeResolver | Scope â†’ color resolution |
| TMRegistry | Grammar loading and caching |
| ThemeRegistry | Theme loading, selection, persistence |
| Resources | 17 grammar JSONs, 13 theme JSONs bundled |

---

## Architecture Deep Dive

### Package Structure

```
Packages/
â”œâ”€â”€ DevysCore/
â”‚   â”œâ”€â”€ Package.swift
â”‚   â””â”€â”€ Sources/DevysCore/
â”‚       â”œâ”€â”€ Workspace/
â”‚       â”‚   â”œâ”€â”€ Workspace.swift           # Workspace model
â”‚       â”‚   â”œâ”€â”€ WorkspaceManager.swift    # CRUD + persistence
â”‚       â”‚   â””â”€â”€ WorkspaceState.swift      # Panel layout state
â”‚       â”‚
â”‚       â”œâ”€â”€ FileSystem/
â”‚       â”‚   â”œâ”€â”€ CEWorkspaceFileNode.swift # Class-based file/folder model (CodeEdit-inspired)
â”‚       â”‚   â”œâ”€â”€ FileTreeViewModel.swift   # Flattened tree + expansion state
â”‚       â”‚   â”œâ”€â”€ FileSystemWatcher.swift   # DispatchSource-based FS monitoring
â”‚       â”‚   â”œâ”€â”€ FileSystemService.swift   # Tree building + file operations
â”‚       â”‚   â””â”€â”€ FileOperations.swift      # Read, list, stat operations
â”‚       â”‚
â”‚       â””â”€â”€ Panels/
â”‚           â”œâ”€â”€ PanelContent.swift        # Enum of panel content types
â”‚           â””â”€â”€ PanelState.swift          # Panel configuration
â”‚
â”œâ”€â”€ DevysSyntax/                          # Shiki-compatible syntax highlighting
â”‚   â”œâ”€â”€ Package.swift
â”‚   â””â”€â”€ Sources/DevysSyntax/
â”‚       â”œâ”€â”€ Oniguruma/
â”‚       â”‚   â”œâ”€â”€ OnigRegex.swift           # Swift wrapper for Oniguruma
â”‚       â”‚   â””â”€â”€ OnigScanner.swift         # Multi-pattern scanner
â”‚       â”‚
â”‚       â”œâ”€â”€ TextMate/
â”‚       â”‚   â”œâ”€â”€ TMGrammar.swift           # Grammar data model
â”‚       â”‚   â”œâ”€â”€ TMTokenizer.swift         # Core tokenization engine
â”‚       â”‚   â”œâ”€â”€ TMRegistry.swift          # Grammar loading & caching
â”‚       â”‚   â””â”€â”€ RuleStack.swift           # State management
â”‚       â”‚
â”‚       â”œâ”€â”€ Theme/
â”‚       â”‚   â”œâ”€â”€ ShikiTheme.swift          # Theme data model
â”‚       â”‚   â”œâ”€â”€ ThemeResolver.swift       # Scope â†’ color resolution
â”‚       â”‚   â””â”€â”€ ThemeRegistry.swift       # Theme loading & selection
â”‚       â”‚
â”‚       â”œâ”€â”€ Integration/
â”‚       â”‚   â”œâ”€â”€ SyntaxHighlighter.swift   # Async highlighting helper
â”‚       â”‚   â””â”€â”€ LanguageDetector.swift    # File ext â†’ language mapping
â”‚       â”‚
â”‚       â””â”€â”€ Resources/
â”‚           â”œâ”€â”€ Grammars/                 # 17 TextMate grammar JSONs
â”‚           â””â”€â”€ Themes/                   # 13 Shiki theme JSONs
â”‚
â””â”€â”€ DevysUI/
    â”œâ”€â”€ Package.swift
    â””â”€â”€ Sources/DevysUI/
        â”œâ”€â”€ DesignSystem/
        â”‚   â”œâ”€â”€ DevysColors.swift         # Color tokens
        â”‚   â”œâ”€â”€ DevysTypography.swift     # Typography tokens
        â”‚   â””â”€â”€ DevysSpacing.swift        # Spacing tokens
        â”‚
        â”œâ”€â”€ Components/
        â”‚   â”œâ”€â”€ Sidebar/
        â”‚   â”‚   â”œâ”€â”€ ActivitySidebar.swift  # Main left sidebar
        â”‚   â”‚   â”œâ”€â”€ FileTreeView.swift     # LazyVStack virtualized tree
        â”‚   â”‚   â”œâ”€â”€ FileTreeRow.swift      # Single file/folder row (optimized)
        â”‚   â”‚   â””â”€â”€ WorkspaceSwitcher.swift # Workspace dropdown
        â”‚   â”‚
        â”‚   â”œâ”€â”€ Panels/
        â”‚   â”‚   â”œâ”€â”€ FileViewerPanel.swift  # Read-only file view
        â”‚   â”‚   â”œâ”€â”€ EmptyPaneView.swift    # Empty state
        â”‚   â”‚   â””â”€â”€ PanelHeader.swift      # Panel title bar
        â”‚   â”‚
        â”‚   â””â”€â”€ Common/
        â”‚       â”œâ”€â”€ DevysButton.swift      # Styled button
        â”‚       â”œâ”€â”€ DevysIcon.swift        # Icon wrapper
        â”‚       â””â”€â”€ StatusIndicator.swift  # Colored dot indicator
        â”‚
        â””â”€â”€ Extensions/
            â”œâ”€â”€ Color+Hex.swift            # Hex color init
            â””â”€â”€ View+Styling.swift         # Common view modifiers
```

### Data Models

```swift
// Workspace.swift
import Foundation

struct Workspace: Identifiable, Codable {
    let id: UUID
    var name: String
    var path: URL
    var lastOpened: Date
    var panelLayout: PanelLayout?
    
    init(name: String, path: URL) {
        self.id = UUID()
        self.name = name
        self.path = path
        self.lastOpened = Date()
        self.panelLayout = nil
    }
}

struct PanelLayout: Codable {
    // Serializable representation of Bonsplit layout
    var tree: PanelNode
}

enum PanelNode: Codable {
    case pane(PaneData)
    case split(orientation: SplitOrientation, children: [PanelNode], ratios: [CGFloat])
}

struct PaneData: Codable {
    var tabs: [TabData]
    var selectedTabIndex: Int
}

struct TabData: Codable {
    let id: UUID
    var filePath: String?  // nil for empty tabs
    var title: String
}
```

```swift
// CEWorkspaceFileNode.swift
// Inspired by CodeEdit's CEWorkspaceFile - uses class for reference semantics
import Foundation
import Combine

final class CEWorkspaceFileNode: Identifiable, ObservableObject, Hashable {
    let id: UUID
    let url: URL
    let isDirectory: Bool
    
    // Parent reference for tree traversal (weak to avoid retain cycles)
    weak var parent: CEWorkspaceFileNode?
    
    // Children (nil = not loaded, empty = loaded but no children)
    @Published var children: [CEWorkspaceFileNode]?
    @Published var isExpanded: Bool = false
    
    // Computed properties
    var name: String { url.lastPathComponent }
    var depth: Int {
        var d = 0
        var current = parent
        while current != nil {
            d += 1
            current = current?.parent
        }
        return d
    }
    
    var icon: String {
        if isDirectory {
            return isExpanded ? "folder.fill" : "folder"
        }
        return Self.fileTypeIcon(for: url.pathExtension)
    }
    
    var iconColor: String {
        if isDirectory { return "secondary" }
        switch url.pathExtension.lowercased() {
        case "swift": return "orange"
        case "js", "ts", "jsx", "tsx": return "yellow"
        case "json": return "green"
        case "md": return "blue"
        case "py": return "blue"
        case "rs": return "orange"
        default: return "tertiary"
        }
    }
    
    init(url: URL, isDirectory: Bool, parent: CEWorkspaceFileNode? = nil) {
        self.id = UUID()
        self.url = url
        self.isDirectory = isDirectory
        self.parent = parent
    }
    
    // MARK: - Hashable
    static func == (lhs: CEWorkspaceFileNode, rhs: CEWorkspaceFileNode) -> Bool {
        lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    // MARK: - File Type Icons
    static func fileTypeIcon(for ext: String) -> String {
        switch ext.lowercased() {
        case "swift": return "swift"
        case "md", "markdown": return "doc.text"
        case "json": return "curlybraces"
        case "js", "ts", "jsx", "tsx": return "j.square"
        case "py": return "p.square"
        case "rs": return "r.square"
        case "go": return "g.square"
        case "html": return "chevron.left.forwardslash.chevron.right"
        case "css", "scss", "sass": return "paintbrush"
        case "png", "jpg", "jpeg", "gif", "svg", "webp": return "photo"
        case "mp3", "wav", "aac", "flac": return "waveform"
        case "mp4", "mov", "avi", "mkv": return "film"
        case "pdf": return "doc.richtext"
        case "zip", "tar", "gz", "rar": return "doc.zipper"
        case "yml", "yaml": return "list.bullet.rectangle"
        case "xml": return "chevron.left.forwardslash.chevron.right"
        case "sh", "bash", "zsh": return "terminal"
        case "dockerfile": return "shippingbox"
        case "gitignore", "gitattributes": return "arrow.triangle.branch"
        default: return "doc"
        }
    }
}
```

```swift
// FlatFileNode.swift
// Flattened representation for virtualized LazyVStack rendering
struct FlatFileNode: Identifiable {
    let id: UUID
    let node: CEWorkspaceFileNode
    let depth: Int
    let isExpanded: Bool
    let hasChildren: Bool
    let isLastChild: Bool  // For tree line rendering
    
    init(node: CEWorkspaceFileNode, isLastChild: Bool = false) {
        self.id = node.id
        self.node = node
        self.depth = node.depth
        self.isExpanded = node.isExpanded
        self.hasChildren = node.isDirectory && (node.children?.isEmpty == false || node.children == nil)
        self.isLastChild = isLastChild
    }
}
```

```swift
// FileTreeViewModel.swift
// Manages the flattened tree for efficient virtualized rendering
import Foundation
import Combine

@MainActor
final class FileTreeViewModel: ObservableObject {
    @Published var flattenedNodes: [FlatFileNode] = []
    @Published var selectedNode: CEWorkspaceFileNode?
    @Published var isLoading = false
    
    private var rootNode: CEWorkspaceFileNode?
    private var fileWatcher: FileSystemWatcher?
    private var cancellables = Set<AnyCancellable>()
    
    let rootURL: URL
    
    init(rootURL: URL) {
        self.rootURL = rootURL
    }
    
    // MARK: - Tree Loading
    
    func loadTree() async {
        isLoading = true
        defer { isLoading = false }
        
        rootNode = await FileSystemService.buildTree(from: rootURL)
        rebuildFlattenedList()
        startWatching()
    }
    
    // MARK: - Expansion
    
    func toggleExpansion(_ node: CEWorkspaceFileNode) {
        guard node.isDirectory else { return }
        
        node.isExpanded.toggle()
        
        // Load children if needed
        if node.isExpanded && node.children == nil {
            Task {
                await loadChildren(for: node)
                rebuildFlattenedList()
            }
        } else {
            rebuildFlattenedList()
        }
    }
    
    private func loadChildren(for node: CEWorkspaceFileNode) async {
        node.children = await FileSystemService.loadChildren(for: node)
    }
    
    // MARK: - Flattening
    
    private func rebuildFlattenedList() {
        var result: [FlatFileNode] = []
        
        func flatten(_ nodes: [CEWorkspaceFileNode]) {
            for (index, node) in nodes.enumerated() {
                let isLast = index == nodes.count - 1
                result.append(FlatFileNode(node: node, isLastChild: isLast))
                
                if node.isDirectory && node.isExpanded, let children = node.children {
                    flatten(children)
                }
            }
        }
        
        if let root = rootNode, let children = root.children {
            flatten(children)
        }
        
        flattenedNodes = result
    }
    
    // MARK: - File Watching
    
    private func startWatching() {
        fileWatcher = FileSystemWatcher(rootURL: rootURL)
        fileWatcher?.onFileChange = { [weak self] changeType, url in
            Task { @MainActor in
                self?.handleFileChange(changeType, at: url)
            }
        }
        fileWatcher?.startWatching()
    }
    
    private func handleFileChange(_ changeType: FileChangeType, at url: URL) {
        // Debounce and refresh affected portion of tree
        Task {
            // Find the parent node and reload its children
            if let parentNode = findNode(for: url.deletingLastPathComponent()) {
                await loadChildren(for: parentNode)
            } else {
                // Fallback: reload entire tree
                await loadTree()
            }
            rebuildFlattenedList()
        }
    }
    
    private func findNode(for url: URL) -> CEWorkspaceFileNode? {
        func search(_ node: CEWorkspaceFileNode) -> CEWorkspaceFileNode? {
            if node.url == url { return node }
            for child in node.children ?? [] {
                if let found = search(child) { return found }
            }
            return nil
        }
        return rootNode.flatMap { search($0) }
    }
    
    deinit {
        fileWatcher?.stopWatching()
    }
}
```

```swift
// FileSystemWatcher.swift
// DispatchSource-based file system monitoring
import Foundation

enum FileChangeType {
    case created
    case modified
    case deleted
    case renamed
}

final class FileSystemWatcher {
    private let rootURL: URL
    private var directorySources: [String: DispatchSourceFileSystemObject] = [:]
    private let queue = DispatchQueue(label: "com.devys.filewatcher", qos: .utility)
    
    var onFileChange: ((FileChangeType, URL) -> Void)?
    
    // Debouncing
    private var pendingChanges: Set<URL> = []
    private var debounceWorkItem: DispatchWorkItem?
    private let debounceInterval: TimeInterval = 0.1  // 100ms
    
    init(rootURL: URL) {
        self.rootURL = rootURL
    }
    
    func startWatching() {
        watchDirectory(rootURL)
    }
    
    func stopWatching() {
        for (_, source) in directorySources {
            source.cancel()
        }
        directorySources.removeAll()
    }
    
    // Watch a directory for changes
    func watchDirectory(_ url: URL) {
        let path = url.path
        guard directorySources[path] == nil else { return }
        
        let fd = open(path, O_EVTONLY)
        guard fd >= 0 else { return }
        
        let source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fd,
            eventMask: [.write, .delete, .rename, .extend],
            queue: queue
        )
        
        source.setEventHandler { [weak self] in
            self?.handleDirectoryChange(url)
        }
        
        source.setCancelHandler {
            close(fd)
        }
        
        source.activate()
        directorySources[path] = source
    }
    
    func unwatchDirectory(_ url: URL) {
        let path = url.path
        if let source = directorySources.removeValue(forKey: path) {
            source.cancel()
        }
    }
    
    private func handleDirectoryChange(_ url: URL) {
        // Add to pending changes and debounce
        pendingChanges.insert(url)
        
        debounceWorkItem?.cancel()
        debounceWorkItem = DispatchWorkItem { [weak self] in
            guard let self = self else { return }
            let changes = self.pendingChanges
            self.pendingChanges.removeAll()
            
            for changedURL in changes {
                DispatchQueue.main.async {
                    // Determine change type (simplified - could be more sophisticated)
                    self.onFileChange?(.modified, changedURL)
                }
            }
        }
        
        queue.asyncAfter(deadline: .now() + debounceInterval, execute: debounceWorkItem!)
    }
}
```

```swift
// FileSystemService.swift
// Builds file trees and handles file operations
import Foundation

enum FileSystemService {
    
    // MARK: - Tree Building
    
    static func buildTree(from rootURL: URL) async -> CEWorkspaceFileNode {
        let rootNode = CEWorkspaceFileNode(url: rootURL, isDirectory: true)
        rootNode.children = await loadChildren(for: rootNode)
        return rootNode
    }
    
    static func loadChildren(for parent: CEWorkspaceFileNode) async -> [CEWorkspaceFileNode] {
        guard parent.isDirectory else { return [] }
        
        do {
            let contents = try FileManager.default.contentsOfDirectory(
                at: parent.url,
                includingPropertiesForKeys: [.isDirectoryKey, .isHiddenKey],
                options: [.skipsHiddenFiles]
            )
            
            let nodes = contents.compactMap { url -> CEWorkspaceFileNode? in
                // Skip hidden files
                guard !url.lastPathComponent.hasPrefix(".") else { return nil }
                
                let isDirectory = (try? url.resourceValues(forKeys: [.isDirectoryKey]))?.isDirectory ?? false
                return CEWorkspaceFileNode(url: url, isDirectory: isDirectory, parent: parent)
            }
            
            // Sort: directories first, then alphabetically
            return nodes.sorted { lhs, rhs in
                if lhs.isDirectory != rhs.isDirectory {
                    return lhs.isDirectory
                }
                return lhs.name.localizedCaseInsensitiveCompare(rhs.name) == .orderedAscending
            }
        } catch {
            print("Error loading children for \(parent.url): \(error)")
            return []
        }
    }
    
    // MARK: - File Operations
    
    static func readFile(at url: URL) async throws -> String {
        try String(contentsOf: url, encoding: .utf8)
    }
    
    static func fileInfo(at url: URL) throws -> FileInfo {
        let attributes = try FileManager.default.attributesOfItem(atPath: url.path)
        return FileInfo(
            size: attributes[.size] as? Int64 ?? 0,
            modifiedDate: attributes[.modificationDate] as? Date ?? Date(),
            createdDate: attributes[.creationDate] as? Date ?? Date()
        )
    }
}

struct FileInfo {
    let size: Int64
    let modifiedDate: Date
    let createdDate: Date
    
    var formattedSize: String {
        ByteCountFormatter.string(fromByteCount: size, countStyle: .file)
    }
}
```

```swift
// PanelContent.swift
enum PanelContent: Identifiable {
    case fileViewer(url: URL)
    case empty
    
    var id: String {
        switch self {
        case .fileViewer(let url): return "file:\(url.path)"
        case .empty: return "empty"
        }
    }
    
    var title: String {
        switch self {
        case .fileViewer(let url): return url.lastPathComponent
        case .empty: return "Untitled"
        }
    }
    
    var icon: String {
        switch self {
        case .fileViewer(let url): 
            return CEWorkspaceFileNode.fileTypeIcon(for: url.pathExtension)
        case .empty: 
            return "doc"
        }
    }
}
```

---

## UI Components Specification

### 1. Main Window

```swift
// ContentView.swift
struct ContentView: View {
    @StateObject private var workspaceManager = WorkspaceManager()
    @State private var selectedWorkspace: Workspace?
    @State private var sidebarWidth: CGFloat = 240
    @State private var isSidebarVisible = true
    
    var body: some View {
        HStack(spacing: 0) {
            if isSidebarVisible {
                ActivitySidebar(
                    workspace: selectedWorkspace,
                    workspaceManager: workspaceManager,
                    onSelectWorkspace: { workspace in
                        selectedWorkspace = workspace
                    },
                    onOpenFile: { url in
                        openFile(url)
                    }
                )
                .frame(width: sidebarWidth)
                
                Divider()
            }
            
            WorkspaceCanvasView(workspace: $selectedWorkspace)
        }
        .background(DevysColors.base)
    }
}
```

### 2. Activity Sidebar

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Workspace Switcher â–¾] â”‚  â† Dropdown to switch workspaces
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         â”‚
â”‚  â–¾ FILES                â”‚  â† Section header
â”‚    ðŸ“ src               â”‚
â”‚      ðŸ“ views           â”‚
â”‚        ðŸ“„ MainView.swiftâ”‚
â”‚      ðŸ“„ App.swift       â”‚
â”‚    ðŸ“ tests             â”‚
â”‚    ðŸ“„ Package.swift     â”‚
â”‚                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â–¾ AGENTS               â”‚  â† Placeholder for M2
â”‚    (Coming in M2)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â–¾ GIT                  â”‚  â† Placeholder for M3
â”‚    (Coming in M3)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```swift
// ActivitySidebar.swift
struct ActivitySidebar: View {
    let workspace: Workspace?
    @ObservedObject var workspaceManager: WorkspaceManager
    let onSelectWorkspace: (Workspace) -> Void
    let onOpenFile: (URL) -> Void
    
    @State private var filesExpanded = true
    @State private var agentsExpanded = true
    @State private var gitExpanded = true
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Workspace Switcher
            WorkspaceSwitcher(
                workspaces: workspaceManager.workspaces,
                selected: workspace,
                onSelect: onSelectWorkspace,
                onCreateNew: { showFolderPicker() }
            )
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
            
            Divider()
            
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // Files Section
                    SidebarSection(
                        title: "FILES",
                        isExpanded: $filesExpanded
                    ) {
                        if let workspace = workspace {
                            FileTreeView(
                                rootURL: workspace.path,
                                onOpenFile: onOpenFile
                            )
                        } else {
                            Text("No workspace selected")
                                .font(DevysTypography.small)
                                .foregroundColor(DevysColors.textTertiary)
                        }
                    }
                    
                    // Agents Section (placeholder)
                    SidebarSection(
                        title: "AGENTS",
                        isExpanded: $agentsExpanded
                    ) {
                        PlaceholderSection(text: "Coming in Milestone 2")
                    }
                    
                    // Git Section (placeholder)
                    SidebarSection(
                        title: "GIT",
                        isExpanded: $gitExpanded
                    ) {
                        PlaceholderSection(text: "Coming in Milestone 3")
                    }
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
            }
        }
        .background(DevysColors.surface)
    }
}
```

### 3. File Tree View (Virtualized with LazyVStack)

> **Key Architecture Decision**: We use a **flattened tree + LazyVStack** pattern instead of recursive SwiftUI views. This ensures only visible rows are rendered, enabling 60fps performance with 5,000+ files.

```swift
// FileTreeView.swift
// Virtualized file tree using LazyVStack for performance
struct FileTreeView: View {
    let rootURL: URL
    let onOpenFile: (URL) -> Void
    
    @StateObject private var viewModel: FileTreeViewModel
    
    init(rootURL: URL, onOpenFile: @escaping (URL) -> Void) {
        self.rootURL = rootURL
        self.onOpenFile = onOpenFile
        _viewModel = StateObject(wrappedValue: FileTreeViewModel(rootURL: rootURL))
    }
    
    var body: some View {
        Group {
            if viewModel.isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if viewModel.flattenedNodes.isEmpty {
                Text("Empty folder")
                    .font(DevysTypography.small)
                    .foregroundColor(DevysColors.textTertiary)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.horizontal, 8)
            } else {
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 0, pinnedViews: []) {
                        ForEach(viewModel.flattenedNodes) { flatNode in
                            FileTreeRow(
                                flatNode: flatNode,
                                isSelected: viewModel.selectedNode?.id == flatNode.id,
                                onSelect: {
                                    viewModel.selectedNode = flatNode.node
                                },
                                onToggleExpand: {
                                    viewModel.toggleExpansion(flatNode.node)
                                },
                                onOpenFile: {
                                    if !flatNode.node.isDirectory {
                                        onOpenFile(flatNode.node.url)
                                    }
                                }
                            )
                        }
                    }
                    .padding(.vertical, 4)
                }
            }
        }
        .task {
            await viewModel.loadTree()
        }
    }
}

// FileTreeRow.swift
// Single row in the file tree - optimized for performance
struct FileTreeRow: View {
    let flatNode: FlatFileNode
    let isSelected: Bool
    let onSelect: () -> Void
    let onToggleExpand: () -> Void
    let onOpenFile: () -> Void
    
    private let indentWidth: CGFloat = 16
    private let rowHeight: CGFloat = 24
    
    var body: some View {
        HStack(spacing: 4) {
            // Indent based on depth
            if flatNode.depth > 0 {
                Spacer()
                    .frame(width: CGFloat(flatNode.depth) * indentWidth)
            }
            
            // Chevron (for directories)
            chevronView
            
            // Icon
            iconView
            
            // Name
            Text(flatNode.node.name)
                .font(DevysTypography.body)
                .foregroundColor(DevysColors.textPrimary)
                .lineLimit(1)
                .truncationMode(.middle)
            
            Spacer(minLength: 0)
        }
        .frame(height: rowHeight)
        .padding(.horizontal, 8)
        .background(isSelected ? DevysColors.primary.opacity(0.15) : Color.clear)
        .cornerRadius(4)
        .contentShape(Rectangle())
        .onTapGesture {
            onSelect()
            if !flatNode.node.isDirectory {
                onOpenFile()
            }
        }
        .simultaneousGesture(
            TapGesture(count: 2).onEnded {
                if flatNode.node.isDirectory {
                    onToggleExpand()
                } else {
                    onOpenFile()
                }
            }
        )
        .contextMenu {
            fileContextMenu
        }
    }
    
    @ViewBuilder
    private var chevronView: some View {
        if flatNode.node.isDirectory {
            Image(systemName: flatNode.isExpanded ? "chevron.down" : "chevron.right")
                .font(.system(size: 10, weight: .medium))
                .foregroundColor(DevysColors.textTertiary)
                .frame(width: 12, height: 12)
                .contentShape(Rectangle())
                .onTapGesture {
                    onToggleExpand()
                }
        } else {
            Spacer().frame(width: 12)
        }
    }
    
    @ViewBuilder
    private var iconView: some View {
        Image(systemName: flatNode.node.icon)
            .font(.system(size: 14))
            .foregroundColor(iconColor)
            .frame(width: 18)
    }
    
    private var iconColor: Color {
        switch flatNode.node.iconColor {
        case "orange": return .orange
        case "yellow": return .yellow
        case "green": return .green
        case "blue": return .blue
        case "secondary": return DevysColors.secondary
        default: return DevysColors.textSecondary
        }
    }
    
    @ViewBuilder
    private var fileContextMenu: some View {
        if flatNode.node.isDirectory {
            Button("New File...") { /* TODO: M4 */ }
            Button("New Folder...") { /* TODO: M4 */ }
            Divider()
        }
        Button("Reveal in Finder") {
            NSWorkspace.shared.selectFile(
                flatNode.node.url.path,
                inFileViewerRootedAtPath: flatNode.node.url.deletingLastPathComponent().path
            )
        }
        Button("Copy Path") {
            NSPasteboard.general.clearContents()
            NSPasteboard.general.setString(flatNode.node.url.path, forType: .string)
        }
        Divider()
        Button("Rename...") { /* TODO: M4 */ }
        Button("Delete", role: .destructive) { /* TODO: M4 */ }
    }
}
```

### Performance Considerations

| Optimization | Description |
|--------------|-------------|
| **Flattened List** | Tree converted to flat array - only expanded nodes included |
| **LazyVStack** | Only visible rows are rendered (virtualization) |
| **Fixed Row Height** | 24px fixed height enables efficient scroll calculations |
| **Minimal View Hierarchy** | Each row is a simple HStack, no nested ForEach |
| **Debounced File Watching** | FS changes batched at 100ms intervals |

### Fallback: NSOutlineView

If performance testing shows < 60fps with 5,000 files, implement this wrapper:

```swift
// NSOutlineViewWrapper.swift (Fallback implementation)
struct NSOutlineViewWrapper: NSViewRepresentable {
    @ObservedObject var viewModel: FileTreeViewModel
    let onOpenFile: (URL) -> Void
    
    func makeNSView(context: Context) -> NSScrollView {
        let scrollView = NSScrollView()
        let outlineView = NSOutlineView()
        
        outlineView.delegate = context.coordinator
        outlineView.dataSource = context.coordinator
        outlineView.headerView = nil
        outlineView.style = .sourceList
        
        // Configure columns
        let column = NSTableColumn(identifier: NSUserInterfaceItemIdentifier("FileColumn"))
        column.isEditable = false
        outlineView.addTableColumn(column)
        outlineView.outlineTableColumn = column
        
        scrollView.documentView = outlineView
        scrollView.hasVerticalScroller = true
        
        return scrollView
    }
    
    func updateNSView(_ nsView: NSScrollView, context: Context) {
        if let outlineView = nsView.documentView as? NSOutlineView {
            outlineView.reloadData()
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(viewModel: viewModel, onOpenFile: onOpenFile)
    }
    
    class Coordinator: NSObject, NSOutlineViewDelegate, NSOutlineViewDataSource {
        let viewModel: FileTreeViewModel
        let onOpenFile: (URL) -> Void
        
        init(viewModel: FileTreeViewModel, onOpenFile: @escaping (URL) -> Void) {
            self.viewModel = viewModel
            self.onOpenFile = onOpenFile
        }
        
        // NSOutlineViewDataSource implementation...
        func outlineView(_ outlineView: NSOutlineView, numberOfChildrenOfItem item: Any?) -> Int {
            // Return children count
            return 0 // Implementation details omitted for brevity
        }
        
        func outlineView(_ outlineView: NSOutlineView, isItemExpandable item: Any) -> Bool {
            guard let node = item as? CEWorkspaceFileNode else { return false }
            return node.isDirectory
        }
        
        // Additional delegate methods...
    }
}
```

### 4. Workspace Canvas (Bonsplit Integration)

```swift
// WorkspaceCanvasView.swift
import SwiftUI
import Bonsplit

struct WorkspaceCanvasView: View {
    @Binding var workspace: Workspace?
    @State private var controller = BonsplitController(
        configuration: devysConfiguration
    )
    @State private var openFiles: [TabID: URL] = [:]
    @StateObject private var delegate = DevysBonsplitDelegate()
    
    var body: some View {
        BonsplitView(controller: controller) { tab in
            // Content for each tab
            if let url = openFiles[tab.id] {
                FileViewerPanel(url: url)
            } else {
                EmptyPaneView(
                    paneId: tab.id,
                    onNewFile: { /* placeholder */ }
                )
            }
        } emptyPane: { paneId in
            EmptyPaneView(
                paneId: paneId,
                onNewFile: { createNewTab(in: paneId) }
            )
        }
        .onAppear {
            controller.delegate = delegate
            delegate.onTabClose = { tabId in
                openFiles.removeValue(forKey: tabId)
            }
        }
    }
    
    func openFile(_ url: URL) {
        // Check if already open
        if let existingTabId = openFiles.first(where: { $0.value == url })?.key {
            controller.selectTab(existingTabId)
            return
        }
        
        // Create new tab
        if let tabId = controller.createTab(
            title: url.lastPathComponent,
            icon: FileNode.fileTypeIcon(for: url.pathExtension),
            isDirty: false
        ) {
            openFiles[tabId] = url
        }
    }
    
    private func createNewTab(in paneId: PaneID) {
        controller.createTab(
            title: "Untitled",
            icon: "doc",
            inPane: paneId
        )
    }
    
    private static var devysConfiguration: BonsplitConfiguration {
        BonsplitConfiguration(
            allowSplits: true,
            allowCloseTabs: true,
            allowCloseLastPane: false,
            allowTabReordering: true,
            allowCrossPaneTabMove: true,
            autoCloseEmptyPanes: false, // Show empty pane view instead
            contentViewLifecycle: .keepAllAlive,
            newTabPosition: .current,
            appearance: BonsplitConfiguration.Appearance(
                tabBarHeight: 36,
                tabMinWidth: 120,
                tabMaxWidth: 240,
                tabSpacing: 1,
                minimumPaneWidth: 200,
                minimumPaneHeight: 150,
                showSplitButtons: true,
                animationDuration: 0.15,
                enableAnimations: true
            )
        )
    }
}

// DevysBonsplitDelegate.swift
class DevysBonsplitDelegate: ObservableObject, BonsplitDelegate {
    var onTabClose: ((TabID) -> Void)?
    
    func splitTabBar(_ controller: BonsplitController,
                     didCloseTab tabId: TabID,
                     fromPane pane: PaneID) {
        onTabClose?(tabId)
    }
    
    func splitTabBar(_ controller: BonsplitController,
                     didSplitPane originalPane: PaneID,
                     newPane: PaneID,
                     orientation: SplitOrientation) {
        // New panes start empty - the emptyPane view will be shown
    }
}
```

### 5. File Viewer Panel (with Live Reload)

```swift
// FileViewerPanel.swift
// Read-only file viewer with live reload when file changes on disk
struct FileViewerPanel: View {
    let url: URL
    
    @State private var content: String = ""
    @State private var fileInfo: FileInfo?
    @State private var isLoading = true
    @State private var error: Error?
    @State private var lastModified: Date?
    
    // File watcher for live reload
    @State private var fileWatcher: DispatchSourceFileSystemObject?
    
    var body: some View {
        VStack(spacing: 0) {
            // File info header
            if let info = fileInfo {
                fileInfoBar(info)
            }
            
            Divider()
            
            // Content
            if isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if let error = error {
                ErrorView(error: error, onRetry: { Task { await loadFile() } })
            } else {
                CodeView(content: content, language: language)
            }
        }
        .background(DevysColors.base)
        .task {
            await loadFile()
            startWatchingFile()
        }
        .onDisappear {
            stopWatchingFile()
        }
    }
    
    @ViewBuilder
    private func fileInfoBar(_ info: FileInfo) -> some View {
        HStack(spacing: 12) {
            // File size
            Label(info.formattedSize, systemImage: "doc")
                .font(DevysTypography.small)
                .foregroundColor(DevysColors.textTertiary)
            
            // Modified date
            Label(info.modifiedDate.formatted(date: .abbreviated, time: .shortened), systemImage: "clock")
                .font(DevysTypography.small)
                .foregroundColor(DevysColors.textTertiary)
            
            Spacer()
            
            // Language badge
            Text(language.uppercased())
                .font(DevysTypography.small)
                .foregroundColor(DevysColors.textSecondary)
                .padding(.horizontal, 6)
                .padding(.vertical, 2)
                .background(DevysColors.elevated)
                .cornerRadius(4)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(DevysColors.surface)
    }
    
    private var language: String {
        LanguageDetector.detect(from: url.path)
    }
    
    private func loadFile() async {
        isLoading = true
        error = nil
        
        do {
            content = try await FileSystemService.readFile(at: url)
            fileInfo = try FileSystemService.fileInfo(at: url)
            lastModified = fileInfo?.modifiedDate
            isLoading = false
        } catch {
            self.error = error
            isLoading = false
        }
    }
    
    // MARK: - File Watching for Live Reload
    
    private func startWatchingFile() {
        let fd = open(url.path, O_EVTONLY)
        guard fd >= 0 else { return }
        
        let source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fd,
            eventMask: [.write, .extend, .attrib],
            queue: .main
        )
        
        source.setEventHandler { [self] in
            Task {
                // Check if file actually changed (avoid false positives)
                if let newInfo = try? FileSystemService.fileInfo(at: url),
                   newInfo.modifiedDate != lastModified {
                    await loadFile()
                }
            }
        }
        
        source.setCancelHandler {
            close(fd)
        }
        
        source.activate()
        fileWatcher = source
    }
    
    private func stopWatchingFile() {
        fileWatcher?.cancel()
        fileWatcher = nil
    }
}

// ErrorView.swift
struct ErrorView: View {
    let error: Error
    let onRetry: () -> Void
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 40, weight: .thin))
                .foregroundColor(DevysColors.warning)
            
            Text("Unable to load file")
                .font(DevysTypography.heading)
                .foregroundColor(DevysColors.textPrimary)
            
            Text(error.localizedDescription)
                .font(DevysTypography.body)
                .foregroundColor(DevysColors.textSecondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 32)
            
            DevysButton(title: "Retry", icon: "arrow.clockwise", style: .secondary) {
                onRetry()
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// CodeView.swift â€” Shiki-style syntax highlighting via DevysSyntax
struct CodeView: View {
    let content: String
    let language: String
    
    @Environment(ThemeRegistry.self) private var themeRegistry
    @State private var highlightedContent: AttributedString?
    @State private var isHighlighting = false
    
    private let lineHeight: CGFloat = 20
    
    var body: some View {
        ScrollView([.horizontal, .vertical]) {
            HStack(alignment: .top, spacing: 0) {
                // Line numbers gutter
                lineNumbersView
                
                Divider()
                
                // Syntax-highlighted code content
                codeContentView
            }
        }
        .task(id: content + language + (themeRegistry.currentThemeName)) {
            await highlightCode()
        }
    }
    
    @ViewBuilder
    private var lineNumbersView: some View {
        VStack(alignment: .trailing, spacing: 0) {
            ForEach(1...max(lineCount, 1), id: \.self) { line in
                Text("\(line)")
                    .font(DevysTypography.codeSmall)
                    .foregroundColor(DevysColors.textTertiary)
                    .frame(height: lineHeight)
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 8)
        .background(DevysColors.surface.opacity(0.5))
    }
    
    @ViewBuilder
    private var codeContentView: some View {
        Group {
            if let highlighted = highlightedContent {
                // Shiki-highlighted code
                Text(highlighted)
            } else {
                // Fallback while highlighting (or if failed)
                Text(content)
                    .foregroundColor(DevysColors.textPrimary)
            }
        }
        .font(DevysTypography.code)
        .textSelection(.enabled)
        .lineSpacing(2)
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .frame(minWidth: 0, maxWidth: .infinity, alignment: .leading)
    }
    
    private var lineCount: Int {
        content.components(separatedBy: "\n").count
    }
    
    // MARK: - Syntax Highlighting
    
    private func highlightCode() async {
        guard !isHighlighting else { return }
        isHighlighting = true
        
        defer { isHighlighting = false }
        
        guard let resolver = themeRegistry.resolver() else {
            highlightedContent = nil
            return
        }
        
        // Tokenize on background thread for large files
        let result = await Task.detached(priority: .userInitiated) {
            SyntaxHighlighter.highlight(
                code: content,
                language: language,
                resolver: resolver
            )
        }.value
        
        await MainActor.run {
            highlightedContent = result
        }
    }
}

// SyntaxHighlighter.swift â€” Convenience wrapper for tokenization
enum SyntaxHighlighter {
    static func highlight(
        code: String,
        language: String,
        resolver: ThemeResolver
    ) -> AttributedString {
        do {
            let grammar = try TMRegistry.shared.grammar(for: language)
            let tokenizer = TMTokenizer(grammar: grammar)
            
            var attributed = AttributedString()
            var prevState: RuleStack? = nil
            
            let lines = code.split(separator: "\n", omittingEmptySubsequences: false)
            
            for (index, line) in lines.enumerated() {
                let lineStr = String(line)
                let result = tokenizer.tokenizeLine(line: lineStr, prevState: prevState)
                prevState = result.endState
                
                // Apply tokens to this line
                var lineAttr = AttributedString(lineStr)
                
                for token in result.tokens {
                    let style = resolver.resolve(scopes: token.scopes)
                    
                    // Apply foreground color
                    let start = lineStr.index(lineStr.startIndex, offsetBy: token.range.lowerBound)
                    let end = lineStr.index(lineStr.startIndex, offsetBy: min(token.range.upperBound, lineStr.count))
                    
                    if let range = lineAttr.range(of: String(lineStr[start..<end])) {
                        lineAttr[range].foregroundColor = Color(nsColor: style.foreground)
                        
                        if style.bold {
                            lineAttr[range].font = DevysTypography.code.bold()
                        }
                        if style.italic {
                            lineAttr[range].font = DevysTypography.code.italic()
                        }
                    }
                }
                
                attributed.append(lineAttr)
                
                if index < lines.count - 1 {
                    attributed.append(AttributedString("\n"))
                }
            }
            
            return attributed
        } catch {
            // Fallback to plain text on error
            return AttributedString(code)
        }
    }
}

// LanguageDetector.swift â€” File extension to language ID mapping
enum LanguageDetector {
    private static let extensionMap: [String: String] = [
        // High priority (most common)
        "swift": "swift",
        "py": "python",
        "js": "javascript",
        "ts": "typescript",
        "tsx": "tsx",
        "jsx": "jsx",
        "html": "html",
        "htm": "html",
        "css": "css",
        "scss": "scss",
        "json": "json",
        "md": "markdown",
        "markdown": "markdown",
        
        // Medium priority
        "rb": "ruby",
        "rs": "rust",
        "c": "c",
        "h": "c",
        "cpp": "cpp",
        "cc": "cpp",
        "cxx": "cpp",
        "hpp": "cpp",
        "go": "go",
        "php": "php",
        "java": "java",
        "kt": "kotlin",
        
        // Other
        "yaml": "yaml",
        "yml": "yaml",
        "toml": "toml",
        "xml": "xml",
        "sh": "shellscript",
        "bash": "shellscript",
        "zsh": "shellscript",
        "sql": "sql",
    ]
    
    static func detect(from filePath: String?) -> String {
        guard let path = filePath else { return "plaintext" }
        let ext = (path as NSString).pathExtension.lowercased()
        return extensionMap[ext] ?? "plaintext"
    }
}
```

### 6. Empty Pane View

```swift
// EmptyPaneView.swift
struct EmptyPaneView: View {
    let paneId: PaneID
    let onNewFile: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "doc.badge.plus")
                .font(.system(size: 48, weight: .thin))
                .foregroundColor(DevysColors.textTertiary)
            
            Text("No Open Files")
                .font(DevysTypography.heading)
                .foregroundColor(DevysColors.textSecondary)
            
            Text("Open a file from the sidebar or drag one here")
                .font(DevysTypography.body)
                .foregroundColor(DevysColors.textTertiary)
                .multilineTextAlignment(.center)
            
            HStack(spacing: 12) {
                DevysButton(
                    title: "Open File",
                    icon: "doc",
                    style: .secondary
                ) {
                    // Open file picker
                }
                
                DevysButton(
                    title: "New File",
                    icon: "plus",
                    style: .primary
                ) {
                    onNewFile()
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(DevysColors.base)
    }
}
```

### 7. Workspace Switcher

```swift
// WorkspaceSwitcher.swift
struct WorkspaceSwitcher: View {
    let workspaces: [Workspace]
    let selected: Workspace?
    let onSelect: (Workspace) -> Void
    let onCreateNew: () -> Void
    
    @State private var isExpanded = false
    
    var body: some View {
        Menu {
            ForEach(workspaces) { workspace in
                Button {
                    onSelect(workspace)
                } label: {
                    HStack {
                        Image(systemName: "folder.fill")
                        Text(workspace.name)
                        if workspace.id == selected?.id {
                            Image(systemName: "checkmark")
                        }
                    }
                }
            }
            
            Divider()
            
            Button {
                onCreateNew()
            } label: {
                HStack {
                    Image(systemName: "plus")
                    Text("Open Folder...")
                }
            }
        } label: {
            HStack {
                Image(systemName: "folder.fill")
                    .foregroundColor(DevysColors.secondary)
                
                Text(selected?.name ?? "No Workspace")
                    .font(DevysTypography.emphasis)
                    .foregroundColor(DevysColors.textPrimary)
                
                Spacer()
                
                Image(systemName: "chevron.up.chevron.down")
                    .font(.system(size: 10))
                    .foregroundColor(DevysColors.textTertiary)
            }
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(DevysColors.elevated)
            .cornerRadius(6)
        }
        .menuStyle(.borderlessButton)
    }
}
```

---

## Design System Implementation

### DevysColors.swift

```swift
import SwiftUI

enum DevysColors {
    // MARK: - Backgrounds
    static let base = Color(hex: "#0a0a0c")
    static let surface = Color(hex: "#12131a")
    static let elevated = Color(hex: "#1a1b24")
    static let border = Color(hex: "#2a2b36")
    
    // MARK: - Accents
    static let primary = Color(hex: "#10b981")     // Emerald
    static let secondary = Color(hex: "#6366f1")   // Indigo
    static let warning = Color(hex: "#f59e0b")     // Amber
    static let error = Color(hex: "#ef4444")       // Red
    
    // MARK: - Text
    static let textPrimary = Color(hex: "#f4f4f5")
    static let textSecondary = Color(hex: "#a1a1aa")
    static let textTertiary = Color(hex: "#71717a")
    
    // MARK: - Status
    static let statusRunning = Color(hex: "#22c55e")
    static let statusPending = Color(hex: "#eab308")
    static let statusComplete = Color(hex: "#3b82f6")
    static let statusError = Color(hex: "#ef4444")
}

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}
```

### DevysTypography.swift

```swift
import SwiftUI

enum DevysTypography {
    // MARK: - UI Fonts (SF Pro)
    static let small = Font.system(size: 11)
    static let body = Font.system(size: 13)
    static let emphasis = Font.system(size: 13, weight: .medium)
    static let heading = Font.system(size: 15, weight: .semibold)
    static let title = Font.system(size: 18, weight: .bold)
    
    // MARK: - Code Fonts
    static let code = Font.custom("Berkeley Mono", size: 13)
        .fallback(Font.system(size: 13, design: .monospaced))
    static let codeSmall = Font.custom("Berkeley Mono", size: 11)
        .fallback(Font.system(size: 11, design: .monospaced))
}

extension Font {
    func fallback(_ fallback: Font) -> Font {
        // In production, check if custom font is available
        // For now, return self
        return self
    }
}
```

### DevysSpacing.swift

```swift
import SwiftUI

enum DevysSpacing {
    static let xxs: CGFloat = 4
    static let xs: CGFloat = 8
    static let sm: CGFloat = 12
    static let md: CGFloat = 16
    static let lg: CGFloat = 24
    static let xl: CGFloat = 32
    static let xxl: CGFloat = 48
    
    static let cornerRadiusSm: CGFloat = 4
    static let cornerRadiusMd: CGFloat = 6
    static let cornerRadiusLg: CGFloat = 8
}
```

### DevysButton.swift

```swift
import SwiftUI

struct DevysButton: View {
    let title: String
    let icon: String?
    let style: ButtonStyle
    let action: () -> Void
    
    enum ButtonStyle {
        case primary
        case secondary
        case ghost
    }
    
    init(
        title: String,
        icon: String? = nil,
        style: ButtonStyle = .secondary,
        action: @escaping () -> Void
    ) {
        self.title = title
        self.icon = icon
        self.style = style
        self.action = action
    }
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                if let icon = icon {
                    Image(systemName: icon)
                        .font(.system(size: 12, weight: .medium))
                }
                Text(title)
                    .font(DevysTypography.body)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(backgroundColor)
            .foregroundColor(foregroundColor)
            .cornerRadius(DevysSpacing.cornerRadiusMd)
            .overlay(
                RoundedRectangle(cornerRadius: DevysSpacing.cornerRadiusMd)
                    .stroke(borderColor, lineWidth: 1)
            )
        }
        .buttonStyle(.plain)
    }
    
    private var backgroundColor: Color {
        switch style {
        case .primary: return DevysColors.primary
        case .secondary: return DevysColors.elevated
        case .ghost: return .clear
        }
    }
    
    private var foregroundColor: Color {
        switch style {
        case .primary: return .white
        case .secondary: return DevysColors.textPrimary
        case .ghost: return DevysColors.textSecondary
        }
    }
    
    private var borderColor: Color {
        switch style {
        case .primary: return .clear
        case .secondary: return DevysColors.border
        case .ghost: return .clear
        }
    }
}
```

---

## Implementation Tasks

### Phase 0: Project Setup âœ… COMPLETED (2026-01-30)

- [x] Create Xcode workspace with app target
- [x] Initialize `DevysCore` Swift package
- [x] Initialize `DevysUI` Swift package
- [x] Initialize `DevysSyntax` Swift package
- [x] Add Bonsplit as SPM dependency (v1.1.1)
- [x] Add Oniguruma as SPM dependency (placeholder, to be completed in Phase 5)
- [x] Set up design system files (colors, typography, spacing)
- [x] Configure app for macOS 14.0+, dark appearance
- [x] Set up SwiftLint for code quality

**Phase 0 Deliverables:**
- `Package.swift` - Root package with Bonsplit dependency
- `Packages/DevysCore/` - Workspace, FileSystem, Panels models
- `Packages/DevysSyntax/` - LanguageDetector, placeholder for TextMate engine
- `Packages/DevysUI/` - DevysColors, DevysTypography, DevysSpacing, DevysButton, DevysIcon, StatusIndicator
- `Apps/Devys/` - Main app with ContentView placeholder
- `.swiftlint.yml` - SwiftLint configuration
- All packages build and tests pass (17 tests total)

### Phase 0.5: Design System & App Shell âœ… COMPLETED (2026-01-30)

- [x] Implement comprehensive design system with light/dark mode support
- [x] Create `ThemeManager` (@Observable) for theme state
- [x] Implement light/dark mode toggle in sidebar
- [x] Unified app shell (sidebar + tab bar same surface color)
- [x] Content area uses distinct base color
- [x] Integrate Bonsplit for tab/pane management
- [x] Activity sidebar with SF Symbol icons
- [x] Placeholder views for all major features
- [x] Window styling (hidden title bar)
- [x] App launches and runs correctly from Swift Package

**Phase 0.5 Deliverables:**
- `ContentView.swift` - Full app shell with Bonsplit integration
- `DevysApp.swift` - App entry with AppDelegate for proper activation
- `design-system.md` - Comprehensive design principles document
- `ThemeManager` - Observable theme state with colorScheme/nsAppearance
- Unified surface colors for sidebar/tab bar
- Light mode: white content, light gray shell
- Dark mode: dark content, darker shell

### Phase 1: Workspace System (Days 3-4)

- [x] Implement `Workspace` model (completed in Phase 0)
- [x] Implement `WorkspaceManager` with persistence (completed in Phase 0)
- [ ] Create `WorkspaceSwitcher` UI component
- [ ] Add folder picker for new workspaces (NSOpenPanel)
- [ ] Wire up persistence integration
- [ ] Handle workspace deletion and cleanup

### Phase 2: File System Core (Days 5-7)

- [x] Implement `CEWorkspaceFileNode` class model (completed in Phase 0)
- [x] Implement `FileSystemService` for tree building (completed in Phase 0)
- [x] Implement `FileTreeViewModel` with flattening (completed in Phase 0)
- [x] Implement `FileSystemWatcher` with DispatchSource (completed in Phase 0)
- [x] Add debouncing for rapid file changes (100ms) (completed in Phase 0)
- [ ] Handle file watching for expanded directories
- [ ] Test with large directories (5,000+ files)

### Phase 4: File Tree UI (Days 8-10)

- [ ] Create `FileTreeView` with LazyVStack virtualization
- [ ] Create `FileTreeRow` optimized component
- [ ] Handle expand/collapse with tree flattening
- [ ] Add file type icons (SF Symbols)
- [ ] Implement context menus (Reveal in Finder, Copy Path)
- [ ] Add selection state management
- [ ] Performance test: verify 60fps with 5,000 files
- [ ] (Fallback) Implement NSOutlineView wrapper if needed

### Phase 5: Bonsplit Integration âœ… COMPLETED (2026-01-30)

- [x] Configure `BonsplitController` with Devys styling
- [x] Implement workspace view with BonsplitView
- [x] Handle tab creation/selection
- [x] Implement split pane functionality
- [x] Create `EmptyPaneView`
- [x] Tab content views with proper backgrounds
- [ ] Test tab drag between panes (deferred - needs testing)
- [ ] Verify 120fps during panel resize (deferred - needs testing)

### Phase 6: DevysSyntax Core Engine (Days 14-17)

> See [shiki-integration.md](shiki-integration.md) for full details

- [ ] Create Oniguruma Swift wrapper (`OnigRegex`, `OnigScanner`)
- [ ] Implement `TMGrammar` data model (Codable)
- [ ] Implement `TMRegistry` for grammar loading/caching
- [ ] Implement `RuleStack` for state management
- [ ] Implement `TMTokenizer` core algorithm
- [ ] Implement `ShikiTheme` data model (Codable)
- [ ] Implement `ThemeResolver` (scope â†’ color matching)
- [ ] Implement `ThemeRegistry` (theme loading, selection, persistence)
- [ ] Bundle 17 TextMate grammar JSON files
- [ ] Bundle 13 Shiki theme JSON files
- [ ] Implement `LanguageDetector` (file ext â†’ language)
- [ ] Implement `SyntaxHighlighter` async helper
- [ ] Add unit tests for tokenizer and theme resolver

### Phase 7: File Viewer with Syntax Highlighting (Days 18-19)

- [ ] Implement `FileViewerPanel` with live reload
- [ ] Create `CodeView` with Shiki highlighting integration
- [ ] Add file info header (size, modified date, language)
- [ ] Implement per-file DispatchSource watcher
- [ ] Handle binary file detection (show error/preview)
- [ ] Add text selection support
- [ ] Create `ErrorView` component
- [ ] Test highlighting with all 17 languages
- [ ] Verify theme switching works

### Phase 8: Activity Sidebar âœ… COMPLETED (2026-01-30)

- [x] Create activity sidebar with icon buttons
- [x] Implement sidebar with SF Symbol icons
- [x] Add placeholder sections for all features (Files, Search, Git, Chat, Settings)
- [x] Add light/dark mode toggle
- [x] Tooltips with keyboard shortcuts
- [ ] Implement sidebar resize with drag handle (deferred)
- [ ] Collapsible sections (deferred - using icon-only sidebar)

### Phase 9: Polish & Integration (Days 22-25)

- [ ] Add keyboard shortcuts (âŒ˜\, âŒ˜W, âŒ˜1-9, etc.)
- [ ] Add theme picker UI (13 themes)
- [ ] Test window resizing behavior
- [ ] Handle edge cases (no workspace, empty files, permission errors)
- [ ] Memory profiling and optimization
- [ ] Performance test: syntax highlighting on large files (10k lines)
- [ ] Visual polish pass
- [ ] Accessibility audit (VoiceOver, keyboard nav)

### Phase 9: Testing & Documentation (Days 21-23)

- [ ] Write unit tests for `CEWorkspaceFileNode`
- [ ] Write unit tests for `FileTreeViewModel`
- [ ] Write unit tests for `FileSystemWatcher`
- [ ] Write UI tests for main flows
- [ ] Performance benchmarking (document results)
- [ ] Create sample workspace for demos
- [ ] Document public APIs
- [ ] Create M1 completion report

---

## Acceptance Criteria

### Must Have

1. **Workspace Creation** â€” User can open a folder and it becomes a workspace
2. **Workspace Switching** â€” User can switch between multiple workspaces
3. **File Navigation** â€” User can browse files/folders in sidebar
4. **File Viewing** â€” User can open and view file contents
5. **Tab Management** â€” User can open multiple files in tabs
6. **Pane Splitting** â€” User can split panes horizontally/vertically
7. **Tab Drag & Drop** â€” User can reorder tabs and move between panes
8. **Workspace Persistence** â€” Workspaces and layouts survive app restart
9. **File System Watching** â€” Tree auto-updates when files are created/deleted/renamed
10. **Live File Reload** â€” Open file viewer updates when file changes on disk

### Should Have

1. **Line Numbers** â€” Code view shows line numbers
2. **File Info Display** â€” Show file size, modified date, language in viewer
3. **Keyboard Shortcuts** â€” âŒ˜\ for sidebar, âŒ˜W for close tab
4. **File Icons** â€” Different icons for different file types (30+ types)
5. **Smooth Animations** â€” 120fps panel resize/drag
6. **Context Menus** â€” Right-click for Reveal in Finder, Copy Path

### Nice to Have

1. **Command Palette** â€” âŒ˜K to open command palette
2. **Quick Open** â€” âŒ˜P to search files
3. **Recent Files** â€” Track recently opened files
4. **NSOutlineView Fallback** â€” If LazyVStack perf < 60fps with 5k files

---

## Technical Decisions

### Why Bonsplit?

| Alternative | Pros | Cons | Decision |
|-------------|------|------|----------|
| Bonsplit | Native Swift, 120fps, drag-drop, maintained | macOS only | âœ… Use it |
| Custom implementation | Full control | Significant effort | âŒ Not worth it for M1 |
| NSTabViewController | Built-in | No splits, limited customization | âŒ Missing features |

Bonsplit provides exactly what we need with minimal integration effort. We can always fork/modify if needed later.

### File Tree: LazyVStack vs NSOutlineView

| Approach | Pros | Cons | Decision |
|----------|------|------|----------|
| LazyVStack + Flattening | Pure SwiftUI, iOS compatible, easier styling | Need manual virtualization | âœ… Primary |
| NSOutlineView | Native perf, built-in virtualization | AppKit mixing, harder styling | ðŸ”„ Fallback |

**Strategy**: Start with LazyVStack. If < 60fps with 5,000 files, migrate to NSOutlineView wrapper.

**Why class-based FileNode?**
- Reference semantics needed for parent pointers
- Tree mutations without full rebuild
- ObservableObject for reactive updates
- Matches CodeEdit's proven architecture

### File System Watching

| Approach | Pros | Cons | Decision |
|----------|------|------|----------|
| DispatchSource | Native, low overhead, per-file granularity | Manual FD management | âœ… Use it |
| FSEvents | Directory-level, handles renames | Higher level, less control | âŒ Overkill |
| Polling | Simple | Wasteful, delayed | âŒ Bad UX |

**Debouncing**: 100ms batch window to avoid UI thrashing during rapid changes (e.g., `git checkout`).

### State Management

Using SwiftUI's native state management:
- `@State` for local view state
- `@StateObject` for owned observable objects (ViewModels)
- `@ObservedObject` for passed observable objects
- `@MainActor` for main-thread safety with async operations

No external state management libraries needed for M1.

### File System Access

Using native Foundation APIs:
- `FileManager` for file operations
- `URL` for file references  
- `DispatchSource.makeFileSystemObjectSource` for real-time file watching
- `O_EVTONLY` flag for notification-only file descriptors

No need for third-party file system libraries.

---

## Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Bonsplit integration issues | High | Low | Early integration testing in Phase 5, fallback to custom tabs |
| LazyVStack performance < 60fps | Medium | Medium | NSOutlineView fallback ready, performance gate at 5k files |
| File watcher FD exhaustion | Medium | Low | Limit watched directories to expanded folders only |
| Memory with many open files | Medium | Low | `.keepAllAlive` with LRU eviction for 20+ tabs |
| DispatchSource race conditions | Medium | Low | All FS callbacks dispatched to @MainActor |
| macOS version compatibility | Low | Low | Target macOS 14.0+, test on 14.0 and 15.0 |
| Large file handling (>10MB) | Low | Medium | Detect large files, show warning, lazy load |

### Performance Gates

| Checkpoint | Metric | Target | Action if Failed |
|------------|--------|--------|------------------|
| Phase 4 complete | File tree scroll FPS | â‰¥ 60fps @ 5k files | Implement NSOutlineView |
| Phase 5 complete | Panel resize FPS | â‰¥ 120fps | Profile Bonsplit, optimize |
| Phase 6 complete | File reload latency | < 100ms | Optimize watcher debouncing |
| Phase 8 complete | Memory (10 files open) | < 200MB | Audit allocations |

---

## Success Metrics for M1

### Performance Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| App launch (cold) | < 1s | Instruments: App Launch |
| App launch (warm) | < 500ms | Instruments: App Launch |
| File tree load (1k files) | < 300ms | os_signpost timing |
| File tree load (5k files) | < 1s | os_signpost timing |
| File tree scroll | â‰¥ 60fps | Instruments: Core Animation |
| Tab switch | < 50ms | No perceived lag |
| Panel resize/drag | â‰¥ 120fps | Instruments: Core Animation |
| File open (100KB file) | < 100ms | os_signpost timing |
| FS change â†’ UI update | < 200ms | Manual timing |

### Memory Metrics

| Scenario | Target | Measurement |
|----------|--------|-------------|
| Idle, 1 workspace | < 100MB | Activity Monitor |
| 5 files open | < 150MB | Activity Monitor |
| 10 files open | < 200MB | Activity Monitor |
| 5k file tree loaded | < 50MB additional | Instruments: Allocations |

### Quality Metrics

| Metric | Target |
|--------|--------|
| Crash-free rate | 100% during testing |
| Unit test coverage | > 70% for Core package |
| Accessibility | VoiceOver navigable |
| SwiftLint warnings | 0 |

---

## Appendix: Key Learnings from CodeEdit

1. **NSOutlineView > SwiftUI OutlineGroup** â€” SwiftUI's built-in tree components have performance issues
2. **Class-based file nodes** â€” Need reference semantics for parent pointers and efficient mutations
3. **DispatchSource for file watching** â€” Low overhead, native, reliable
4. **Flattened tree for virtualization** â€” Only way to get LazyVStack performance with trees
5. **Debounce file changes** â€” Batch rapid FS events to avoid UI thrashing

---

*Milestone 1 is the foundation. Everything we build here must be solid, beautiful, and extensible.*
